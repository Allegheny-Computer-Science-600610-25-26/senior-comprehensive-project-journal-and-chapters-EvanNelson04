# Method of approach

## Overview of WorkoutTracker

WorkoutTracker is a dynamic fitness app designed to help users log, monitor, analyze, and receive evaluations on their workouts in a seamless 
and visually engaging way. Beyond simply recording exercises, the app provides charts, trend analysis, and personalized evaluations, 
allowing users to track progress, identify patterns, and receive actionable insights on strength, endurance, and fatigue. Its architecture 
emphasizes a single source of truth for workout data, ensuring that every logged session automatically updates history views, progress 
visualizations, and predictive assessments in real time. The intuitive interface and integrated analytics make it a tool not just for 
tracking workouts, but for optimizing training and staying motivated over the long term.

The purpose of WorkoutTracker is to provide users with free and accessible tools to track and evaluate their workouts, helping them 
improve over time. While fitness can often feel complicated, this app simplifies progress tracking, emphasizing that real growth comes 
from commitment, consistency, and determination. Providing the mobile fitness world with this application will finally solve the problem
of receiving free and concise feedback and analysis to benefit the user. 

WorkoutTracker is designed for fitness enthusiasts of all levels, from beginners who want to establish consistent workout habits to advanced 
athletes aiming to monitor performance trends and optimize training. Its intuitive interface and automated tracking features make it accessible 
to anyone, regardless of prior experience with fitness apps. Users can log individual exercises, track weight and repetitions, monitor heart 
rate, and view historical progress, enabling them to make data-driven decisions about their training routine. Whether the goal is building 
strength, improving endurance, or maintaining overall fitness, the app supports consistent tracking and evaluation over time.

## System Architecture

![App Overview Image](images/Overview.png)

The overall architecture of WorkoutTracker is designed to provide a seamless, reactive experience for users while maintaining a simple design.
As seen in the flowchart above, there are many moving pieces within this application that are important to note and explain. Many of these
pages communicate together and work together to produce one functioning application. Explaining the Xcode platform and the Swift language will be
completed first, after that there are 6 different pages that will be explained: History, Progress, Awards, Suggestions, Add, and Profile. 

### Xcode 

Xcode is Apple’s integrated development environment (IDE) for building applications across its platforms, including iOS, iPadOS, macOS and watchOS. 
It provides developers with a complete toolkit, including a code editor, interface builder, simulator, debugging tools, and project management, 
all in one environment. For a mobile app like WorkoutTracker, Xcode allows for rapid development and testing, letting developers design 
interactive interfaces visually while simultaneously writing and compiling Swift code. It allows users to utilize themselves as a prototype tester
for their app by providing the users with 2 choices. Test the app on provided simulators of chosen platform (iOS, watchOS, etc...), or est the app 
on their own device 

While Xcode provides simulators for iOS, watchOS, and other Apple platforms, testing on a live device offers a more accurate understanding of 
how the app performs in real-world conditions. Simulators are helpful for quickly checking layouts and basic functionality, but they cannot 
fully replicate device-specific behaviors such as actual touch responsiveness, performance under load, battery usage, or integration with 
hardware features such as local user creation.

To test WorkoutTracker on a live device, the following steps were taken:

1. Device Preparation: The iPhone was connected via USB to the development computer. The device was trusted and registered with Xcode.
2. Provisioning and Signing: A free or paid Apple Developer account was used to set up a provisioning profile and code signing for the device.
3. Selecting the Device in Xcode: In Xcode, the target device was selected from the run destination menu instead of the simulator.
4. Building and Running: The app was built and deployed directly to the device using Xcode’s Run command.
5. Live Testing: The app was interacted with on the device to verify UI responsiveness, chart updates, data entry, and performance in real usage scenarios.

By completing these steps, this allowed my mobile phone to have a running version of my current computational artifact during development. Which
enabled testing of many aspects of the app that were previously mentioned. There are many additional key features of Xcode that are worth hightlighting.

Xcode is very tightly intergrated with swift, Apple's primary programming language. It provides realt-time syntax highlighting, error 
detection, and compile-time checks, allowing developers to identify and correct issues early in the development process. This tight integration 
improves code reliability and reduces debugging time.

Xcode includes advanced debugging tools such as breakpoints, variable inspection, and console logging. Additionally, Instruments allows 
developers to profile CPU usage, memory consumption, and energy impact. These tools are especially important for a fitness app like 
WorkoutTracker, where performance efficiency and battery usage are critical during prolonged use.

Xcode’s Interface Builder and SwiftUI Previews allow developers to visually design user interfaces and immediately see changes reflected in 
real time. This significantly speeds up UI iteration and ensures layouts adapt properly across different screen sizes and device types.

Xcode has built-in Git support, allowing developers to track changes, manage branches, and revert to previous versions directly within the 
IDE. This is essential for maintaining code stability as features are added or modified throughout development. Haing built-in GIT support was
crucial for this project. It allows continuous work saving within a repository that can be tracked and viewed by my colleagues and professors.

Xcode manages the full application lifecycle—from development and testing to archiving and preparing the app for distribution via 
TestFlight or the App Store. This makes it a centralized tool not only for development but also for deployment and maintenance.

Xcode provides detailed build logs and warnings that help developers understand compilation errors and runtime issues. This feedback is 
crucial for debugging logic errors and ensuring the app meets Apple’s platform requirements. Overall, Xcode serves as a comprehensive 
development environment that supports the entire workflow of the WorkoutTracker app, from initial design and coding to real-device testing, 
performance optimization, and eventual deployment.

### User Authentication

### Add Workout 

### Workout Log

### Progress / Evaluation 

### Profile

### Awards 

### Suggestions

## Data Flow and Processing Pipeline

This section introduces the data flow and processing pipeline used in the WorkoutTracker application. It explains how user-entered workout 
data moves through the system, from initial input to final output, and how each stage contributes to the app’s overall functionality. Rather 
than focusing solely on individual code segments, this section emphasizes the logical flow of data and the design decisions behind it, 
supported by a flowchart and selected code examples. This approach provides a clear understanding of how raw workout data is transformed into 
meaningful metrics, summaries, and visualizations presented to the user.

![Data Pipeline Flowchart](images/DataFlow.png)

Let's start with how the data gets inputted from the user. As seen in the flowchart, the user-inputted data starts all the following processes.
In WorkoutTracker, data querying does not run continuously. This means that everything becomes powered and runs when the user presses the save
button which finalizes the data they are inputting. This folows what is called an event-driven model, where queries are triggered only when
specific events occur, in this case being when the user logs a workout. Other cases within this app are when the user navigates to the progress
page to view visualizations. When no new data is being entered or requested, the querying logic becomes idle, consuming no processing resources. 
This design was carefully developed to ensure efficient resource usage, avoiding unnecessary computation, and improves battery performance which
is critical when working in app development. This also aligns with modern mobile app development standards, where data processing is reactive rather
than continuously running.

```swift
1  let entry = WorkoutEntry(
2    date: Date(),
3    muscleGroup: cleanMuscleGroup,
4    exercise: cleanExercise,
5    weight: Double(weight) ?? 0,
6    reps: Int(reps) ?? 0,
7    heartRate: Double(heartRate)
8  )
```

This code structures every data input that app recieves from the user. As you can see in the flowchart, once the user adds a workout, it creates
a "WorkoutEntry". This function processes every input that is recieved and structures them the same way every time. This allows for easy coding
when it comes to looping through the data to find specific inputs. Each input is made up of six parts with one of them being optional, date, muscle
group, exercise, weight, reps, and the optional choice to input heart-rate. Every time an input is recieved, it is then transformed into this
structure and then finally appended to list "Data.entries"

This list as seen in the flowchart is the color teal. This list contains all of the data inputs that the user has ever provided the app. So as
the user continues to add hundreds of inputs the list continues to get larger. WorkoutData.entries is an in-memory data structure rather than a 
JSON object. It is implemented as a Swift array containing strongly typed workout entry models, such as structs that represent individual 
workout records. This array exists only while the application is running and is used by the app’s logic and user interface to query, process, 
and display workout information efficiently. JSON is involved only when this data needs to be persisted or loaded; in that case, the Swift 
objects stored in WorkoutData.entries are serialized into a JSON file for local storage and later deserialized back into Swift objects when 
the app is relaunched. This separation between runtime data structures and storage format ensures type safety, efficient processing, and clean 
state management within the application. 

By appending each incoming input to the same list in the same structure, it enables much easier coding when it comes to PR querying, or data
visualization. It only requires a for each loop to then parse through the list and check for any specific detail the developer wants. For 
example if the developer was looking to collect all of the exercises that are working out a specific muscle group it would look like this. 

```swift
1  workoutData.entries.forEach { entry in
2    if entry.muscleGroup == targetMuscle {
3       matchingExercises.append(entry)
4    }
5  }
```

Within this code snippet, you can see that it is parsing through every entry within the list and looking for the targetMuscle, which would
have been initialized before the loop. If the targetMuscle was declared as "legs," then the matchingExercises list would solely contain
all the exercises that have muscleGroup as legs. Swift makes for each loop very simple by only requiring three things for this specific 
example. First, what are you parsing through in this case, specifically, the name of the list. Secondly, you need to specify what you want the for
each loop to do once it gets to a data input, in this case, looking for a specific muscle group, and then finally appending the data only if
it matches the desired muscle group.

Moving forward in the flow chart, we can see that this list WorkoutData.entries, fuels the rest of the processes. There are three different 
pages that take data from this list: History, Progress (charts and evaluation), and Profile. All of these different sections of WorkoutTracker
actively us different queries to update data. 

WorkoutListView (history) is the page where the user is able to view a log of all the workouts they have entered into the app. Within this page
users have the ability to delete specific entries if they mis-entered information or wish to remove an entry. All that this page is doing 
is displaying the list of entries in a neat and easily readable output. There are two important code parts that go into this page. 

```swift
1  var body: some View {
2    NavigationView {
3      ZStack {
4        // Full screen gradient
5        AppColors.gradient
6          .ignoresSafeArea()
7        List {
8          ForEach(workoutData.entries) { entry in
9            WorkoutCard(entry: entry)
10              .listRowBackground(Color.clear) // make row background transparent
11              .listRowSeparator(.hidden)      // hide default separator
12          }
13          .onDelete(perform: workoutData.delete)
14        }
15        .listStyle(PlainListStyle()) // remove extra padding & default style
16      }
17      .navigationTitle("Workout History")
18      .navigationBarTitleDisplayMode(.inline)
19    }
20  }
```


This SwiftUI code defines the user interface for a "Workout History" screen. The main view is a NavigationView containing a ZStack, which 
allows layering of elements. At the back of the stack, a full-screen gradient defined by AppColors.gradient is displayed and extended to 
cover the safe area using .ignoresSafeArea(). On top of this gradient, a List presents all workout entries stored in workoutData.entries 
using ForEach, where each entry is represented by a custom WorkoutCard view. Each list row is customized to have a transparent background 
(.listRowBackground(Color.clear)) and no default separator (.listRowSeparator(.hidden)), giving it a clean, card-like appearance. Users can 
also delete entries with swipe actions via .onDelete(perform:). The list uses PlainListStyle() to remove extra padding and the default list 
styling, and the navigation bar is set with the title "Workout History," displayed inline for a compact appearance.

This view shows a user-friendly “Workout History” screen where each workout is displayed as a card. The colorful gradient in the background 
makes the screen visually appealing, while the list of workouts scrolls on top of it. Each card is easy to read because the rows are 
transparent and have no separators, giving a clean, modern look. Users can also swipe to delete workouts, and the navigation bar at the top 
clearly shows the title of the screen. Overall, this layout combines style and functionality in a simple, organized way.

The next part that is important for this page 

\begin{figure}[h!]
\centering
\begin{lstlisting}1  VStack(alignment: .leading, spacing: 6) {
2    HStack {
3      Text(entry.exercise)
4        .font(.headline)
5        .foregroundColor(.white)
6      Spacer()
7      Text("\(Int(entry.weight)) lbs x \(entry.reps)")
8        .font(.subheadline)
9        .foregroundColor(.white.opacity(0.9))
10    }    
11                       
12    HStack(spacing: 12) {
13      if let hr = entry.heartRate {
14        Label("\(Int(hr)) bpm", systemImage: "heart.fill")
15          .font(.caption)
16          .foregroundColor(hr > 140 ? .red : .green)
17      }
18                        
19      Label(entry.date.formatted(.dateTime.month().day().year()), systemImage: "calendar")
20        .font(.caption)
21        .foregroundColor(.white.opacity(0.8))
22    }
23  }
\end{lstlisting}
\caption{Layout of a single workout entry in the `WorkoutCard` view.}
\label{fig:workoutcard}
\end{figure}

This SwiftUI code defines the layout of a single workout entry in a vertical stack (VStack) with a small spacing of 6 points between its 
elements, aligned to the leading edge. The first horizontal stack (HStack) displays the exercise name on the left in a bold headline font 
with white text, and on the right, it shows the weight lifted and the number of repetitions in a slightly smaller, semi-transparent white 
font. A Spacer() between them pushes the two pieces of text to opposite sides. Below that, a second HStack with a spacing of 12 points shows 
additional details: if the workout entry includes a heart rate, it displays it with a heart icon in a caption font, coloring it red if the 
rate is above 140 bpm and green otherwise. Next to that, a calendar icon with the formatted workout date is displayed, also in a caption font
and semi-transparent white. Overall, this layout creates a clean, organized card showing both the main workout information and supplemental 
details like heart rate and date.

The first code snippet defines the overall screen layout, using a NavigationView with a scrollable List that displays all workout entries, 
while the second snippet defines what each individual entry looks like inside that list as a WorkoutCard. Essentially, the List in the first 
snippet loops over all workoutData.entries and places a WorkoutCard for each one, creating a full workout history view. The WorkoutCard layout, 
shown in the second snippet, organizes the exercise name, weight, reps, heart rate, and date in a clean, readable format using vertical and 
horizontal stacks. Together, the two snippets work in tandem: the first handles the overall structure, scrolling, and navigation, and the 
second handles the content and styling of each row, resulting in a cohesive, visually appealing workout history screen.

 








